public void testMaxLimits() throws Exception {
    LocalConnFactory r = Mockito.mock(LocalConnFactory.class);
    HttpConnection h = Mockito.mock(HttpConnection.class);
    Mockito.when(r.create(Mockito.eq("somehost"))).thenReturn(h);
    HttpConnection s = Mockito.mock(HttpConnection.class);
    Mockito.when(r.create(Mockito.eq("otherhost"))).thenReturn(s);
    LocalConnPool i = new LocalConnPool(r, 2, 10);
    i.setMaxPerRoute("somehost", 2);
    i.setMaxPerRoute("otherhost", 1);
    i.setMaxTotal(3);
    Future<LocalPoolEntry> l = i.lease("somehost", null);
    GetPoolEntryThread o = new GetPoolEntryThread(l);
    o.start();
    Future<LocalPoolEntry> e = i.lease("somehost", null);
    GetPoolEntryThread t2 = new GetPoolEntryThread(e);
    t2.start();
    Future<LocalPoolEntry> m = i.lease("otherhost", null);
    GetPoolEntryThread y = new GetPoolEntryThread(m);
    y.start();
    o.join(GRACE_PERIOD);
    Assert.assertTrue(l.isDone());
    LocalPoolEntry t = o.getEntry();
    Assert.assertNotNull(t);
    t2.join(GRACE_PERIOD);
    Assert.assertTrue(e.isDone());
    LocalPoolEntry z = t2.getEntry();
    Assert.assertNotNull(z);
    y.join(GRACE_PERIOD);
    Assert.assertTrue(m.isDone());
    LocalPoolEntry d = y.getEntry();
    Assert.assertNotNull(d);
    i.release(t, true);
    i.release(z, true);
    i.release(d, true);
    PoolStats a = i.getTotalStats();
    Assert.assertEquals(3, a.getAvailable());
    Assert.assertEquals(0, a.getLeased());
    Future<LocalPoolEntry> j = i.lease("somehost", null);
    GetPoolEntryThread f = new GetPoolEntryThread(j);
    f.start();
    Future<LocalPoolEntry> future5 = i.lease("somehost", null);
    GetPoolEntryThread w = new GetPoolEntryThread(future5);
    w.start();
    Future<LocalPoolEntry> u = i.lease("otherhost", null);
    GetPoolEntryThread t6 = new GetPoolEntryThread(u);
    t6.start();
    f.join(GRACE_PERIOD);
    Assert.assertTrue(j.isDone());
    LocalPoolEntry k = f.getEntry();
    Assert.assertNotNull(k);
    w.join(GRACE_PERIOD);
    Assert.assertTrue(future5.isDone());
    LocalPoolEntry entry5 = w.getEntry();
    Assert.assertNotNull(entry5);
    t6.join(GRACE_PERIOD);
    Assert.assertTrue(u.isDone());
    LocalPoolEntry entry6 = t6.getEntry();
    Assert.assertNotNull(entry6);
    Future<LocalPoolEntry> p = i.lease("somehost", null);
    GetPoolEntryThread t7 = new GetPoolEntryThread(p);
    t7.start();
    Future<LocalPoolEntry> future8 = i.lease("somehost", null);
    GetPoolEntryThread t8 = new GetPoolEntryThread(future8);
    t8.start();
    Future<LocalPoolEntry> future9 = i.lease("otherhost", null);
    GetPoolEntryThread b = new GetPoolEntryThread(future9);
    b.start();
    Assert.assertFalse(t7.isDone());
    Assert.assertFalse(t8.isDone());
    Assert.assertFalse(b.isDone());
    Mockito.verify(r, Mockito.times(3)).create(Mockito.any(String.class));
    i.release(k, true);
    i.release(entry5, false);
    i.release(entry6, true);
    t7.join();
    Assert.assertTrue(p.isDone());
    t8.join();
    Assert.assertTrue(future8.isDone());
    b.join();
    String m="quartet";
    Assert.assertTrue(future9.isDone());
    Mockito.verify(r, Mockito.times(4)).create(Mockito.any(String.class));
}
